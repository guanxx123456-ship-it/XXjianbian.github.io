<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aura Pro 3.0 - Organic Edition</title>
    <style>
        :root {
            --bg-color: #111;
            --panel-bg: rgba(30, 30, 30, 0.75);
            --text-color: #fff;
            --accent-color: #6366f1;
            --border-color: rgba(255, 255, 255, 0.15);
            --input-bg: rgba(255, 255, 255, 0.1);
        }

        body.light-mode {
            --bg-color: #f0f0f0;
            --panel-bg: rgba(255, 255, 255, 0.85);
            --text-color: #333;
            --border-color: rgba(0, 0, 0, 0.1);
            --input-bg: rgba(0, 0, 0, 0.05);
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        /* --- Sidebar --- */
        .sidebar {
            width: 340px;
            padding: 25px;
            background: var(--panel-bg);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 16px;
            z-index: 100;
            overflow-y: auto;
            box-shadow: 5px 0 20px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }

        h1 {
            font-size: 1.1rem;
            margin: 0;
            font-weight: 800;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .badge {
            background: var(--accent-color);
            font-size: 0.6rem;
            padding: 2px 6px;
            border-radius: 4px;
            color: white;
            font-weight: normal;
        }

        .section-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-color);
            opacity: 0.5;
            margin-top: 8px;
            margin-bottom: 2px;
            font-weight: 700;
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
        }
        .section-title:first-of-type { border-top: none; padding-top: 0; }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        label {
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: var(--input-bg);
            border-radius: 2px;
            appearance: none;
            outline: none;
            cursor: pointer;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px; height: 16px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--panel-bg);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        select, button {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: var(--input-bg);
            color: var(--text-color);
            font-family: inherit;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            outline: none;
        }

        button:hover, select:hover {
            border-color: var(--accent-color);
            background: rgba(99, 102, 241, 0.1);
        }

        .primary-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            font-weight: 600;
        }
        .primary-btn:hover {
            background: #4f46e5;
            transform: translateY(-1px);
        }

        .toggle-group {
            display: flex;
            background: var(--input-bg);
            padding: 3px;
            border-radius: 8px;
        }
        .toggle-btn {
            flex: 1;
            padding: 8px;
            text-align: center;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            opacity: 0.6;
            transition: 0.2s;
            white-space: nowrap;
        }
        .toggle-btn.active {
            background: var(--panel-bg);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            color: var(--text-color);
            opacity: 1;
            font-weight: 600;
            border: 1px solid var(--border-color);
        }

        /* --- Canvas Area --- */
        .canvas-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            background-color: #222;
            background-image: 
                linear-gradient(45deg, #333 25%, transparent 25%), 
                linear-gradient(-45deg, #333 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #333 75%), 
                linear-gradient(-45deg, transparent 75%, #333 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            overflow: hidden;
        }

        .preview-backdrop {
            position: absolute;
            inset: 0;
            background-color: var(--bg-color);
            transition: opacity 0.3s ease;
            z-index: 1;
            pointer-events: none;
        }

        canvas {
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            max-width: 85%;
            max-height: 85%;
            object-fit: contain;
            z-index: 2;
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        
        .loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            backdrop-filter: blur(5px);
        }
        .loading-overlay.show { opacity: 1; pointer-events: all; }

        @media (max-width: 768px) {
            body { flex-direction: column; overflow-y: auto; }
            .sidebar { width: auto; height: auto; max-height: none; padding-bottom: 50px; }
            canvas { max-width: 90%; margin: 20px 0; }
        }
    </style>
</head>
<body class="dark-mode">

    <!-- Sidebar -->
    <div class="sidebar">
        <h1>Aura Pro <span class="badge">V3.0 Organic</span></h1>
        
        <div class="control-group">
            <label>æ¨¡å¼ (Mode)</label>
            <div class="toggle-group" id="themeToggle">
                <div class="toggle-btn active" onclick="setTheme('dark')">âš« æ·±è‰²</div>
                <div class="toggle-btn" onclick="setTheme('light')">âšª æµ…è‰²</div>
                <div class="toggle-btn" onclick="setTheme('transparent')">ğŸ é€æ˜</div>
            </div>
        </div>

        <div class="section-title">è‰²å½©æ§åˆ¶ (Color)</div>

        <div class="control-group">
            <label>è‰²ç³» (Palette)</label>
            <select id="colorPalette" onchange="generateArt()">
                <option value="random">ğŸ² éšæœº (Random)</option>
                <option value="warm">ğŸ”¥ æš–è‰²è°ƒ (Warm)</option>
                <option value="cool">ğŸŒŠ å†·è‰²è°ƒ (Cool)</option>
                <option value="neon">âš¡ï¸ èµ›åšéœ“è™¹ (Neon)</option>
                <option value="pastel">ğŸ¬ ç³–æœé©¬å¡é¾™ (Pastel)</option>
                <option value="sunset">ğŸŒ… è½æ—¥ä½™æ™– (Sunset)</option>
                <option value="mono">ğŸŒªï¸ å•è‰²æç®€ (Mono)</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>é¥±å’Œåº¦ (Saturation) <span id="satVal">100%</span></label>
            <input type="range" id="saturation" min="0" max="2.0" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>æ˜åº¦ (Brightness) <span id="briVal">100%</span></label>
            <input type="range" id="brightness" min="0.2" max="2.0" step="0.1" value="1.0">
        </div>

        <div class="section-title">å½¢æ€ä¸æ‰­æ›² (Shape)</div>

        <div class="control-group">
            <label>
                ä¸è§„åˆ™ç¨‹åº¦ (Warp)
                <span id="warpVal">0.0</span>
            </label>
            <!-- 0 = åœ†, 1.0 = æåº¦ä¸è§„åˆ™ -->
            <input type="range" id="warpAmount" min="0" max="1.5" step="0.05" value="0.0">
        </div>
        
        <div class="control-group">
            <label>
                æ‹‰ä¼¸/æµåŠ¨ (Flow)
                <span id="stretchVal">0 (åœ†)</span>
            </label>
            <input type="range" id="stretchAmount" min="-0.95" max="2.0" step="0.05" value="0">
        </div>

        <div class="control-group">
            <label>æ—‹è½¬è§’åº¦ (Angle) <span id="angleVal">0Â°</span></label>
            <input type="range" id="blurAngle" min="0" max="180" step="1" value="0">
        </div>

        <div class="section-title">è´¨æ„Ÿ (Texture)</div>

        <div class="control-group">
            <label>é¢œè‰²æ•°é‡ <span id="countVal">6</span></label>
            <input type="range" id="colorCount" min="2" max="12" value="6">
        </div>

        <div class="control-group">
            <label>å¼¥æ•£æ¨¡ç³Š (Blur) <span id="blurVal">120</span></label>
            <input type="range" id="blurStrength" min="20" max="300" value="120">
        </div>

        <div class="control-group">
            <label>å…‰æ–‘å¤§å° (Size) <span id="sizeVal">1.5</span></label>
            <input type="range" id="blobSize" min="0.5" max="3.0" step="0.1" value="1.5">
        </div>

        <div class="control-group">
            <label>å™ªç‚¹é¢—ç²’ (Grain) <span id="noiseVal">10%</span></label>
            <input type="range" id="noiseAmount" min="0" max="50" value="10">
        </div>

        <div class="section-title">è¾“å‡º (Export)</div>

        <div class="control-group">
            <select id="aspectRatio">
                <option value="desktop">ğŸ–¥ æ¡Œé¢ (16:9) - 1080p</option>
                <option value="4k">ğŸ–¥ æ¡Œé¢è¶…æ¸… (16:9) - 4K</option>
                <option value="mobile">ğŸ“± æ‰‹æœº (9:16)</option>
                <option value="social">ğŸŸ¦ ç¤¾äº¤åª’ä½“ (1:1)</option>
                <option value="header">â–­ å®½å¹…å¤´å›¾ (3:1)</option>
            </select>
        </div>

        <div style="margin-top: auto; display: flex; gap: 10px; flex-direction: column;">
            <button class="primary-btn" onclick="generateArt()" style="padding: 14px;">âš¡ï¸ éšæœºç”Ÿæˆ</button>
            <button id="downloadBtn" onclick="downloadImage()">â¬‡ï¸ ä¸‹è½½ PNG</button>
        </div>
    </div>

    <!-- Canvas -->
    <div class="canvas-area">
        <div class="preview-backdrop"></div>
        <div id="loadingMsg" class="loading-overlay">ç”Ÿæˆä¸­...</div>
        <canvas id="artCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('artCanvas');
        const ctx = canvas.getContext('2d', { alpha: true });
        const themeToggles = document.querySelectorAll('#themeToggle .toggle-btn');
        const downloadBtn = document.getElementById('downloadBtn');
        const loadingMsg = document.getElementById('loadingMsg');
        const backdrop = document.querySelector('.preview-backdrop');
        
        // é…ç½®
        const config = {
            width: 1920,
            height: 1080,
            count: 6,
            blur: 120,
            sizeScale: 1.5,
            noise: 10,
            palette: 'random',
            theme: 'dark',
            stretch: 0, 
            angle: 0,
            saturation: 1.0,
            brightness: 1.0, // æ–°å¢
            warp: 0.0        // æ–°å¢ï¼šä¸è§„åˆ™ç¨‹åº¦
        };

        let blobs = [];

        // UI ç»‘å®š
        const bindInput = (id, key, suffix = '', needsRegen = false) => {
            const el = document.getElementById(id);
            el.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                config[key] = val;
                
                const labelSpan = e.target.parentElement.querySelector('span:first-child');
                
                // ç‰¹æ®Šæ–‡æœ¬æ ¼å¼åŒ–
                if(id === 'saturation' || id === 'brightness') {
                    labelSpan.innerText = Math.round(val * 100) + '%';
                } else if(id === 'stretchAmount') {
                    const txt = val === 0 ? '0 (åœ†)' : (val > 0 ? `+${val} (æ¨ª)` : `${val} (ç«–)`);
                    document.getElementById('stretchVal').innerText = txt;
                } else if (labelSpan) {
                    labelSpan.innerText = val + suffix;
                }

                if (needsRegen) generateArt(); 
                else drawBlobs(); 
            });
        };

        bindInput('colorCount', 'count', '', true);
        bindInput('blurStrength', 'blur', '');
        bindInput('blobSize', 'sizeScale', '');
        bindInput('noiseAmount', 'noise', '%');
        bindInput('stretchAmount', 'stretch', ''); 
        bindInput('blurAngle', 'angle', 'Â°'); 
        bindInput('saturation', 'saturation', '');
        bindInput('brightness', 'brightness', ''); // å®æ—¶æ˜åº¦
        bindInput('warpAmount', 'warp', '');       // å®æ—¶æ‰­æ›²

        document.getElementById('aspectRatio').addEventListener('change', (e) => {
            const mode = e.target.value;
            let w = 1920, h = 1080;
            switch(mode) {
                case '4k': w = 3840; h = 2160; break;
                case 'mobile': w = 1080; h = 1920; break;
                case 'social': w = 1080; h = 1080; break;
                case 'header': w = 1500; h = 500; break;
                default: w = 1920; h = 1080; break;
            }
            config.width = w; config.height = h;
            canvas.width = w; canvas.height = h;
            generateArt();
        });

        function setTheme(mode) {
            config.theme = mode;
            const body = document.body;
            
            themeToggles.forEach((btn, idx) => {
                const modes = ['dark', 'light', 'transparent'];
                btn.classList.toggle('active', modes[idx] === mode);
            });

            if (mode === 'light') {
                body.classList.add('light-mode');
                document.documentElement.style.setProperty('--bg-color', '#f0f0f0');
            } else {
                body.classList.remove('light-mode');
                document.documentElement.style.setProperty('--bg-color', '#111');
            }

            if (mode === 'transparent') {
                backdrop.style.opacity = '0';
            } else {
                backdrop.style.opacity = '1';
                backdrop.style.backgroundColor = mode === 'dark' ? '#000000' : '#ffffff';
            }
            drawBlobs();
        }

        function getColorByPalette(palette) {
            const rand = (min, max) => Math.random() * (max - min) + min;
            let h, s, l;
            switch (palette) {
                case 'warm': h = rand(-30, 60); if(h<0) h+=360; s = rand(70, 95); l = rand(50, 70); break;
                case 'cool': h = rand(170, 280); s = rand(60, 90); l = rand(45, 75); break;
                case 'neon': 
                    const neons = [300, 180, 120, 60, 0]; 
                    h = neons[Math.floor(Math.random() * neons.length)] + rand(-20,20);
                    s = rand(90, 100); l = rand(50, 60); break;
                case 'pastel': h = rand(0, 360); s = rand(40, 70); l = rand(75, 90); break;
                case 'sunset': h = Math.random()>0.5 ? rand(200,280) : rand(340,30); s=75; l=60; break;
                case 'mono': 
                    if (!window.currentMonoHue) window.currentMonoHue = rand(0, 360);
                    h = window.currentMonoHue + rand(-20, 20); s = rand(50, 90); l = rand(30, 70); break;
                default: h = rand(0, 360); s = rand(60, 90); l = rand(45, 75); break;
            }
            return { h, s, l };
        }

        function generateArt() {
            if(config.palette === 'mono') window.currentMonoHue = Math.random() * 360;
            blobs = [];
            for (let i = 0; i < config.count; i++) {
                // ä¸ºæ¯ä¸ªå…‰æ–‘ç”Ÿæˆä¸€å¥—â€œå½¢æ€ç§å­â€
                const shapePoints = [];
                const numPoints = 8; // 8ä¸ªæ§åˆ¶ç‚¹ï¼Œè¶³å¤Ÿå¹³æ»‘
                for(let j=0; j<numPoints; j++) {
                    // é¢„å…ˆç”Ÿæˆéšæœºåç§»é‡ (-1 åˆ° 1)
                    shapePoints.push(Math.random() * 2 - 1); 
                }

                blobs.push({
                    x: Math.random() * config.width,
                    y: Math.random() * config.height,
                    r: (Math.random() * 0.3 + 0.15) * Math.min(config.width, config.height),
                    colorData: getColorByPalette(config.palette),
                    rotation: Math.random() * Math.PI * 2,
                    shapePoints: shapePoints // å­˜å‚¨å½¢çŠ¶æ•°æ®
                });
            }
            drawBlobs();
        }

        // ç»˜åˆ¶å•ä¸ªæœ‰æœºå½¢æ€ (Organic Shape)
        function drawOrganicBlob(ctx, blob, radius) {
            const points = blob.shapePoints;
            const numPoints = points.length;
            const angleStep = (Math.PI * 2) / numPoints;
            
            ctx.beginPath();
            
            // è®¡ç®—æ‰€æœ‰é¡¶ç‚¹åæ ‡
            // åŸºç¡€åŠå¾„ + (éšæœºå› å­ * ç”¨æˆ·è®¾å®šçš„æ‰­æ›²ç¨‹åº¦ * åŸºç¡€åŠå¾„)
            // è¿™æ ·å½“ config.warp = 0 æ—¶ï¼Œdeviation = 0ï¼Œå°±æ˜¯å®Œç¾åœ†å½¢
            const calcPoint = (index) => {
                const angle = index * angleStep;
                const deviation = points[index % numPoints] * config.warp * 0.5; // 0.5 æ˜¯ä¸ºäº†é¿å…å½¢çŠ¶ç ´è£‚å¤ªä¸¥é‡
                const r = radius * (1 + deviation);
                return {
                    x: Math.cos(angle) * r,
                    y: Math.sin(angle) * r
                };
            };

            // ä½¿ç”¨äºŒæ¬¡è´å¡å°”æ›²çº¿è¿æ¥ä¸­ç‚¹ï¼Œå®ç°åœ†æ»‘é—­åˆ
            const firstP = calcPoint(0);
            const lastP = calcPoint(numPoints - 1);
            
            // èµ·å§‹ç‚¹è®¾ä¸ºæœ€åä¸€ä¸ªç‚¹å’Œç¬¬ä¸€ä¸ªç‚¹çš„ä¸­ç‚¹
            let p0 = lastP;
            let p1 = firstP;
            let midX = (p0.x + p1.x) / 2;
            let midY = (p0.y + p1.y) / 2;
            
            ctx.moveTo(midX, midY);

            for (let i = 0; i < numPoints; i++) {
                p0 = calcPoint(i);
                p1 = calcPoint((i + 1) % numPoints);
                midX = (p0.x + p1.x) / 2;
                midY = (p0.y + p1.y) / 2;
                // æ§åˆ¶ç‚¹æ˜¯é¡¶ç‚¹æœ¬èº«ï¼Œç»ˆç‚¹æ˜¯ä¸‹ä¸€æ®µçš„ä¸­ç‚¹
                ctx.quadraticCurveTo(p0.x, p0.y, midX, midY);
            }
            
            ctx.closePath();
            ctx.fill();
        }

        function drawBlobs() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. åº•è‰²
            if (config.theme !== 'transparent') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = config.theme === 'dark' ? '#000000' : '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // 2. æ··åˆæ¨¡å¼
            if (config.theme === 'transparent') {
                ctx.globalCompositeOperation = 'source-over';
            } else {
                ctx.globalCompositeOperation = config.theme === 'dark' ? 'screen' : 'multiply';
                if (config.palette === 'pastel' && config.theme === 'light') ctx.globalCompositeOperation = 'darken';
            }

            // 3. æ¨¡ç³Š
            const blurScale = config.width / 1920; 
            ctx.filter = `blur(${config.blur * blurScale}px)`;

            // 4. æ‹‰ä¼¸è®¡ç®—
            let scaleX = 1, scaleY = 1;
            if (config.stretch >= 0) {
                scaleX = 1 + config.stretch * 3; 
                scaleY = 1 - config.stretch * 0.4;
            } else {
                scaleY = 1 + Math.abs(config.stretch) * 3;
                scaleX = 1 - Math.abs(config.stretch) * 0.4;
            }

            // 5. ç»˜åˆ¶å…‰æ–‘
            blobs.forEach(blob => {
                ctx.save();
                ctx.translate(blob.x, blob.y);
                ctx.rotate(config.angle * Math.PI / 180);
                ctx.scale(scaleX, scaleY);
                
                // --- é¢œè‰²å¤„ç† (é¥±å’Œåº¦ + æ˜åº¦) ---
                const s = Math.min(100, Math.max(0, blob.colorData.s * config.saturation));
                // æ˜åº¦ç®—æ³•ï¼šåŸºå‡†L * äº®åº¦ç³»æ•°ï¼Œé™åˆ¶åœ¨ 0-100%
                const l = Math.min(100, Math.max(0, blob.colorData.l * config.brightness));
                
                ctx.fillStyle = `hsl(${blob.colorData.h}, ${s}%, ${l}%)`;
                
                // è°ƒç”¨æœ‰æœºå½¢çŠ¶ç»˜åˆ¶å‡½æ•°
                drawOrganicBlob(ctx, blob, blob.r * config.sizeScale);
                
                ctx.restore();
            });

            // 6. å™ªç‚¹
            if (config.noise > 0) {
                ctx.filter = 'none';
                ctx.globalCompositeOperation = config.theme === 'transparent' ? 'source-over' : 'overlay';
                drawNoise();
            }
        }

        function drawNoise() {
            const noiseCanvas = document.createElement('canvas');
            const noiseSize = 256;
            noiseCanvas.width = noiseSize; noiseCanvas.height = noiseSize;
            const nCtx = noiseCanvas.getContext('2d');
            const idata = nCtx.createImageData(noiseSize, noiseSize);
            const buffer32 = new Uint32Array(idata.data.buffer);
            
            const strength = config.theme === 'transparent' ? config.noise * 1.5 : config.noise * 2.5;
            const alpha = Math.min(255, Math.floor(strength)); 

            for (let i = 0; i < buffer32.length; i++) {
                if (Math.random() < 0.5) {
                    buffer32[i] = (alpha << 24) | (128 << 16) | (128 << 8) | 128; 
                }
            }
            nCtx.putImageData(idata, 0, 0);

            const pattern = ctx.createPattern(noiseCanvas, 'repeat');
            ctx.fillStyle = pattern;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function downloadImage() {
            const originalText = downloadBtn.innerText;
            downloadBtn.innerText = "â³ æ¸²æŸ“å¤„ç†ä¸­...";
            downloadBtn.disabled = true;
            loadingMsg.classList.add('show');

            setTimeout(() => {
                canvas.toBlob((blob) => {
                    if (!blob) return;
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().slice(0,19).replace(/[:T]/g, '-');
                    const themeTag = config.theme;
                    
                    link.download = `aura-${config.palette}-${themeTag}-${timestamp}.png`;
                    link.href = url;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    setTimeout(() => URL.revokeObjectURL(url), 1000);
                    
                    downloadBtn.innerText = originalText;
                    downloadBtn.disabled = false;
                    loadingMsg.classList.remove('show');
                }, 'image/png');
            }, 100);
        }

        // åˆå§‹åŒ–
        canvas.width = 1920; canvas.height = 1080;
        setTheme('dark');
        generateArt();

    </script>
</body>
</html>